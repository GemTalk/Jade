| package |
package := Package name: 'Rowan STON'.
package paxVersion: 1;
	basicComment: ''.

package imageStripperBytes: (ByteArray fromBase64String: 'IVNUQiA0IEYPEQAEAAAASmFkZUltYWdlU3RyaXBwZXIAAAAAAAAAAFIAAAAAAAAAmgAAAFIAAAAQ
AAAARG9scGhpbiBNVlAgQmFzZVIAAAAVAAAAUnVudGltZVNlc3Npb25NYW5hZ2Vy778lAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=').

package classNames
	add: #STON;
	add: #STONListWriter;
	add: #STONMapWriter;
	add: #STONReader;
	add: #STONReaderError;
	add: #STONReference;
	add: #STONShortListWriter;
	add: #STONStreamWriter;
	add: #STONWriter;
	add: #STONWriterError;
	yourself.

package methodNames
	add: #Boolean -> #stonContainSubObjects;
	add: #Boolean -> #stonOn:;
	add: #ByteArray -> #readHexFrom:;
	add: #ByteArray -> #stonContainSubObjects;
	add: #ByteArray -> #stonOn:;
	add: #Character -> #stonOn:;
	add: #Class -> #stonName;
	add: #Collection -> #stonOn:;
	add: #Date -> #_monthAbbrev:;
	add: #Date -> #_yearMonthDay;
	add: #Date -> #asStringUsingFormat:;
	add: #Date -> #stonContainSubObjects;
	add: #Date -> #stonOn:;
	add: #Dictionary -> #stonOn:;
	add: #Dictionary -> #stonProcessSubObjects:;
	add: #Integer -> #stonOn:;
	add: #Interval -> #stonOn:;
	add: #Number -> #stonContainSubObjects;
	add: #Number -> #stonOn:;
	add: #Object -> #fromSton:;
	add: #Object -> #isStonReference;
	add: #Object -> #stonContainSubObjects;
	add: #Object -> #stonOn:;
	add: #Object -> #stonProcessSubObjects:;
	add: #Object -> #stonShouldWriteNilInstVars;
	add: #SequenceableCollection -> #stonOn:;
	add: #SmallInteger -> #_digitsAsString;
	add: #String -> #stonContainSubObjects;
	add: #String -> #stonOn:;
	add: #Symbol -> #stonOn:;
	add: #Time -> #asStringUsingFormat:;
	add: #Time -> #stonContainSubObjects;
	add: #Time -> #stonOn:;
	add: #UndefinedObject -> #stonOn:;
	add: 'ByteArray class' -> #fromSton:;
	add: 'Character class' -> #fromSton:;
	add: 'Collection class' -> #fromSton:;
	add: 'Date class' -> #fromSton:;
	add: 'Date class' -> #fromStream:usingFormat:;
	add: 'Date class' -> #fromString:usingFormat:;
	add: 'Dictionary class' -> #fromSton:;
	add: 'Interval class' -> #fromSton:;
	add: 'Interval class' -> #writeStream;
	add: 'Object class' -> #fromSton:;
	add: 'SequenceableCollection class' -> #fromSton:;
	add: 'Time class' -> #fromSton:;
	add: 'Time class' -> #fromStream:usingFormat:;
	add: 'Time class' -> #fromString:usingFormat:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\Core\Object Arts\Dolphin\Base\Dolphin';
	add: '..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base';
	add: 'Jade Deployment';
	yourself).

package!

"Class Definitions"!

Object subclass: #STON
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #STONReader
	instanceVariableNames: 'readStream objects classes unresolvedReferences stringStream allowComplexMapKeys stack'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #STONReference
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #STONStreamWriter
	instanceVariableNames: 'writer first'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #STONWriter
	instanceVariableNames: 'writeStream prettyPrint newLine jsonMode referencePolicy level objects'
	classVariableNames: 'STONCharacters STONSimpleSymbolCharacters'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Error subclass: #STONReaderError
	instanceVariableNames: 'streamPosition'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Error subclass: #STONWriterError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
STONStreamWriter subclass: #STONListWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
STONStreamWriter subclass: #STONMapWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
STONListWriter subclass: #STONShortListWriter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!Boolean methodsFor!

stonContainSubObjects
	^false!

stonOn: stonWriter
	stonWriter writeBoolean: self! !
!Boolean categoriesFor: #stonContainSubObjects!public!ston! !
!Boolean categoriesFor: #stonOn:!must not strip!public!ston! !

!ByteArray methodsFor!

readHexFrom: aStream
	"Initialize the receiver from a hexadecimal string representation"

	| map v ch value |
	map := '0123456789abcdefABCDEF'.
	1 to: self size
		do: 
			[:i |
			ch := aStream next.
			v := (map indexOf: ch) - 1.
			((v between: 0 and: 15) or: [(v := v - 6) between: 0 and: 15])
				ifFalse: [^self error: 'Hex digit 
expected'].
			value := v bitShift: 4.
			ch := aStream next.
			v := (map indexOf: ch) - 1.
			((v between: 0 and: 15) or: [(v := v - 6) between: 0 and: 15])
				ifFalse: [^self error: 'Hex digit 
expected'].
			value := value + v.
			self at: i put: value]!

stonContainSubObjects
	^false!

stonOn: stonWriter
	"Use a hex representation"

	stonWriter writeObject: self listSingleton: self asHexString ! !
!ByteArray categoriesFor: #readHexFrom:!must not strip!public! !
!ByteArray categoriesFor: #stonContainSubObjects!must not strip!public! !
!ByteArray categoriesFor: #stonOn:!must not strip!public! !

!ByteArray class methodsFor!

fromSton: stonReader
	| singletonString |
	singletonString := stonReader parseListSingleton.
	^(self new: singletonString size // 2) readHexFrom: singletonString readStream! !
!ByteArray class categoriesFor: #fromSton:!must not strip!public! !

!Character methodsFor!

stonOn: stonWriter
	stonWriter writeObject: self listSingleton: self asString
! !
!Character categoriesFor: #stonOn:!must not strip!public! !

!Character class methodsFor!

fromSton: stonReader
	^ stonReader parseListSingleton first
! !
!Character class categoriesFor: #fromSton:!must not strip!public! !

!Class methodsFor!

stonName
	"Override to encode my instances using a different class name."
	
	^ self name! !
!Class categoriesFor: #stonName!public!rowan! !

!Collection methodsFor!

stonOn: stonWriter
	stonWriter writeObject: self do: [
		stonWriter encodeList: self ]
! !
!Collection categoriesFor: #stonOn:!must not strip!public! !

!Collection class methodsFor!

fromSton: stonReader
	| collection |
	collection := self new.
	stonReader parseListDo: [ :each |
		collection add: each ].
	^ collection
! !
!Collection class categoriesFor: #fromSton:!must not strip!public! !

!Date methodsFor!

_monthAbbrev: anIndex
	"ported from GemStone"

	"Private.  Returns a three-letter String that gives the abbreviation, in the
 user's native language, of the name of the month whose numeric index is
 anIndex.  The index is a number between 1 and 12 inclusive, where 1 signifies
 January."

	| theMonth itsAbbrev |
	theMonth := Date nameOfMonth: anIndex.	"get its full name"
	itsAbbrev := String new.
	1 to: 3
		do: 
			[:aChar |
			"take the first three letters"
			itsAbbrev := itsAbbrev , (theMonth at: aChar)].
	^itsAbbrev!

_yearMonthDay
	^Array
		with: self year
		with: self monthIndex
		with: self dayOfMonth!

asStringUsingFormat: anArray
	"adapted from GemStone"

	"Returns a String that expresses the receiver in the format defined by anArray.
 Generates an error if anArray contains an incorrect formatting specification.

 See the class documentation of Date for a complete description of the
 String-formatting specification Array."

	| t dateSeparator monthName aString day yearNumber |
	t := self _yearMonthDay.
	dateSeparator := (anArray at: 4) asString.
	(anArray at: 5) == 2
		ifTrue: [monthName := self _monthAbbrev: (t at: 2)]
		ifFalse: 
			[(anArray at: 5) == 3
				ifTrue: [monthName := Date nameOfMonth: (t at: 2)]
				ifFalse: [monthName := (t at: 2) _digitsAsString]	"month as number is default"].	"get the month name according to the format"
	(anArray at: 6) == 2
		ifTrue: [yearNumber := ((t at: 1) \\ 100) _digitsAsString]
		ifFalse: [yearNumber := (t at: 1) printString].	"YYYY is default"
	day := (t at: 3) _digitsAsString.
	(anArray at: 1) == 2
		ifTrue: [aString := monthName , dateSeparator]
		ifFalse: 
			[(anArray at: 1) == 3
				ifTrue: [aString := yearNumber , dateSeparator]
				ifFalse: [aString := day , dateSeparator]	"yearNumber first"].	"month first"	"day first is default"
	(anArray at: 2) == 1
		ifTrue: [aString := aString , day , dateSeparator]
		ifFalse: 
			[(anArray at: 2) == 3
				ifTrue: [aString := aString , yearNumber , dateSeparator]
				ifFalse: [aString := aString , monthName , dateSeparator]	"month second is default"].	"day second"	"yearNumber second"
	(anArray at: 3) == 1
		ifTrue: [aString := aString , day]
		ifFalse: 
			[(anArray at: 3) == 2
				ifTrue: [aString := aString , monthName]
				ifFalse: [aString := aString , yearNumber]	"month third"].	"day third"	"yearNumber third is default"
	^aString!

stonContainSubObjects 
	^ false
!

stonOn: stonWriter
  "Use an ISO style YYYYMMDD representation"

  stonWriter
    writeObject: self
    listSingleton: (self asStringUsingFormat: #(3 2 1 $- 1 1 $: false))
! !
!Date categoriesFor: #_monthAbbrev:!must not strip!public!ston! !
!Date categoriesFor: #_yearMonthDay!must not strip!public!ston! !
!Date categoriesFor: #asStringUsingFormat:!must not strip!public!ston! !
!Date categoriesFor: #stonContainSubObjects!must not strip!public!ston! !
!Date categoriesFor: #stonOn:!must not strip!public!ston! !

!Date class methodsFor!

fromSton: stonReader

	^ self fromStream: stonReader parseListSingleton readStream usingFormat: #(3 2 1 $- 1 1)
!

fromStream: aStream usingFormat: anArray
	"adapted from GemStone"

	"Creates and returns an instance of the receiver by reading a String from
 aStream.  The String expresses the date in the format specified by anArray.
 The expression is terminated either by a space Character or by the end of the
 Stream.  Generates an error if the String does not conform to the format,
 or if anArray contains an incorrect formatting specification.

 See the class documentation of Date for a complete description of the
 String-formatting specification Array.

 If the month format (5th element) indicates either an abbreviation (2) or an
 entire name (3), then this method tries to determine the month by decoding a
 Character substring.  That substring may include any number of characters, but
 must exactly match a legal month name (or the initial portion of that month
 name).  If the substring matches more than one month, the first month matched
 is used (the search begins with January)."

	| dayInt monthInt yearInt dateDelim result parseField parseBlocks |
	"This block returns a string up from the input stream up to the specified
 delimiter.  If also allows an end-of-file if that parameter is set true.
 It then skips over the delimiter if it is found.
"
	parseField := 
			[:delim :allowEof |
			| str |
			str := aStream contents class new.
			[(aStream peek = delim) not and: [aStream atEnd not]] whileTrue: [str := str , aStream next asString].
			aStream atEnd
				ifTrue: [allowEof ifFalse: [self error: 'Bad Date Format']]
				ifFalse: [aStream next	"skip over delimiter"].
			str].
	parseBlocks := {
				[:delim |
				| nextField |
				nextField := parseField value: delim value: delim = $\x20.
				dayInt := Integer fromString: nextField asString].
				
				[:delim |
				| nextField |
				nextField := parseField value: delim value: delim = $\x20.
				nextField = '' ifTrue: [self error: 'Bad Date Format'].
				(anArray at: 5) == 1
					ifTrue: [monthInt := Integer fromString: nextField asString]
					ifFalse: [monthInt := Date nameOfMonth: nextField asInteger].
				(monthInt < 1 or: [monthInt > 12]) ifTrue: [self error: 'Bad Date Format']].
				
				[:delim |
				| nextField |
				nextField := parseField value: delim value: delim = $\x20.
				yearInt := Integer fromString: nextField asString.
				(anArray at: 6) == 2
					ifTrue: [yearInt > 99 ifFalse: [yearInt := yearInt + (Date today year // 100 * 100)]]]}.
	"parse day"
	"parse month"
	"parse year"
	dateDelim := anArray at: 4.

	"parse the date, with day, month, year in the specified format order"
	(parseBlocks at: (anArray at: 1)) value: dateDelim.
	(parseBlocks at: (anArray at: 2)) value: dateDelim.
	(parseBlocks at: (anArray at: 3)) value: $\x20.
	result := self
				newDay: dayInt
				monthNumber: monthInt
				year: yearInt.
	^result!

fromString: aString usingFormat: anArray
	"adapted from GemStone"

	"Creates and returns an instance of the receiver from the String aString.
 The String expresses the date in the format specified by anArray.  The
 expression is terminated either by a space Character or by the end of the
 String.  Generates an error if the String does not conform to the format,
 or if anArray contains an incorrect formatting specification.

 See the class documentation of Date for a complete description of the
 String-formatting specification Array.

 If the month format (5th element) indicates either an abbreviation (2) or an
 entire name (3), then this method tries to determine the month by decoding a
 character substring.  That substring may include any number of Characters, but
 must exactly match a legal month name (or the initial portion of that month
 name).  If the substring matches more than one month, the first month matched
 is used (the search begins with January)."

	| s result |
	s := ReadStream on: aString.
	result := self fromStream: s usingFormat: anArray.
	[s atEnd] whileFalse: [(s next isEquivalent: $\x20) ifFalse: [self _errIncorrectFormat: aString]].
	^result! !
!Date class categoriesFor: #fromSton:!must not strip!public! !
!Date class categoriesFor: #fromStream:usingFormat:!must not strip!public!ston! !
!Date class categoriesFor: #fromString:usingFormat:!must not strip!public!ston! !

!Dictionary methodsFor!

stonOn: stonWriter
	"Instances of STON mapClass will be encoded directly, without a class tag.
	Other (sub)classes will be encoded with a class tag and will use a map representation. "

	self class == STON mapClass
		ifTrue: [stonWriter writeMap: self]
		ifFalse: [stonWriter writeObject: self do: [stonWriter encodeMap: self]]!

stonProcessSubObjects: block
	"Execute block to (potentially) change each of my subObjects.
	In general, all instance and indexable variables are processed.
	Overwrite when necessary. Not used when #stonContainSubObjects returns false."

	(self class isVariable and: [self class isBytes not and: [self class isIndexable]])
		ifTrue: 
			[1 to: self _basicSize
				do: 
					[:each |
					| val |
					val := block value: (self basicAt: each).
					self basicAt: each put: val]]	"
							super stonProcessSubObjects: block"! !
!Dictionary categoriesFor: #stonOn:!must not strip!public! !
!Dictionary categoriesFor: #stonProcessSubObjects:!must not strip!public! !

!Dictionary class methodsFor!

fromSton: stonReader
	"Instances of STON mapClass will be read directly and won't arrive here.
	Other (sub)classes will use this method."

	| dictionary |
	dictionary := self new.
	stonReader parseMapDo: [:key :value | dictionary at: key put: value].
	^dictionary! !
!Dictionary class categoriesFor: #fromSton:!must not strip!public! !

!Integer methodsFor!

stonOn: stonWriter
	stonWriter writeInteger: self! !
!Integer categoriesFor: #stonOn:!must not strip!public!ston! !

!Interval methodsFor!

stonOn: stonWriter
	stonWriter writeObject: self! !
!Interval categoriesFor: #stonOn:!public!ston! !

!Interval class methodsFor!

fromSton: stonReader
	| result values |
	values := OrderedCollection new.
	stonReader parseMapDo: [:key :value | values add: value].
	values size = 2 ifTrue: [result := self from: values first to: values second].
	values size = 3 ifTrue: [result := self from: values first to: values second by: values third].
	^result!

writeStream
	
	^(self from: 0 to: 0) writeStream! !
!Interval class categoriesFor: #fromSton:!instance creation!private! !
!Interval class categoriesFor: #writeStream!instance creation!private! !

!Number methodsFor!

stonContainSubObjects
	^false!

stonOn: stonWriter
	stonWriter writeFloat: self asFloat! !
!Number categoriesFor: #stonContainSubObjects!public!ston! !
!Number categoriesFor: #stonOn:!must not strip!public!ston! !

!Object methodsFor!

fromSton: stonReader
	"Decode non-variable classes from a map of their instance variables and values.
	Override to customize and add a matching #toSton: (see implementors)."

	self class isVariable
		ifFalse: 
			[| ivNames |
			ivNames := self class allInstVarNames collect: [:nm | nm asSymbol].
			stonReader
				parseMapDo: [:ivName :value | self instVarAt: (ivNames indexOf: ivName asSymbol) put: value]]!

isStonReference
	^ false
!

stonContainSubObjects
	"Return true if I contain subObjects that should be processed, false otherwise.
	Overwrite when necessary. See also #stonProcessSubObjects:"
	
	^ true
!

stonOn: stonWriter
	"Encode non-variable classes with a map of their instance variable and values.
	Override to customize and add a matching #fromSton: (see implementors)."

	self class isVariable 
		ifFalse: [
			stonWriter writeObject: self ]
!

stonProcessSubObjects: block
  "Execute block to (potentially) change each of my subObjects.
	In general, all instance and indexable variables are processed.
	Overwrite when necessary. Not used when #stonContainSubObjects returns false."

  1 to: self class instSize do: [ :each | self instVarAt: each put: (block value: (self instVarAt: each)) ].
  (self class isVariable and: [ self class isBytes not ])
    ifTrue: [ 1 to: self basicSize do: [ :each | self basicAt: each put: (block value: (self basicAt: each)) ] ]
!

stonShouldWriteNilInstVars
	"Return true if my instance variables that are nil should be written out, 
	false otherwise. Overwrite when necessary. By default, return false."
	
	^ false
! !
!Object categoriesFor: #fromSton:!must not strip!public! !
!Object categoriesFor: #isStonReference!must not strip!public! !
!Object categoriesFor: #stonContainSubObjects!must not strip!public! !
!Object categoriesFor: #stonOn:!must not strip!public! !
!Object categoriesFor: #stonProcessSubObjects:!must not strip!public! !
!Object categoriesFor: #stonShouldWriteNilInstVars!must not strip!public! !

!Object class methodsFor!

fromSton: stonReader
	"Create a new instance and delegate decoding to instance side.
	Override only when new instance should be created directly (see implementors). "
	
	^ self new
		fromSton: stonReader;
		yourself
! !
!Object class categoriesFor: #fromSton:!must not strip!public! !

!SequenceableCollection methodsFor!

stonOn: stonWriter
	self class == STON listClass
		ifTrue: [ stonWriter writeList: self ]
		ifFalse: [ super stonOn: stonWriter ]
! !
!SequenceableCollection categoriesFor: #stonOn:!must not strip!public! !

!SequenceableCollection class methodsFor!

fromSton: stonReader
	^ self streamContents: [ :stream |
		stonReader parseListDo: [ :each |
			stream nextPut: each ] ]
! !
!SequenceableCollection class categoriesFor: #fromSton:!must not strip!public! !

!SmallInteger methodsFor!

_digitsAsString
	"adapted from GemStone for ston"

	"Returns self as a String of at least two digits."

	| aString |
	self < 10 ifTrue: [aString := '0' , self printString] ifFalse: [aString := self printString].
	^aString! !
!SmallInteger categoriesFor: #_digitsAsString!must not strip!public!ston! !

!String methodsFor!

stonContainSubObjects
	^false!

stonOn: stonWriter
	"Use an ISO style HH:MM:SS representation"

	stonWriter writeString: self! !
!String categoriesFor: #stonContainSubObjects!public!ston! !
!String categoriesFor: #stonOn:!must not strip!public!ston! !

!Symbol methodsFor!

stonOn: stonWriter
	stonWriter writeSymbol: self! !
!Symbol categoriesFor: #stonOn:!must not strip!public!ston! !

!Time methodsFor!

asStringUsingFormat: anArray
	"adapted from GemStone"

	"Returns a String that expresses the receiver in Greenwich Mean Time
 in the format defined by anArray.  Generates an error if anArray
 contains an incorrect formatting specification.

 See the class documentation of Time for a complete description of the
 String-formatting specification Array."

	| timeSeparator hourInt hour min sec aString |
	timeSeparator := anArray at: 1.
	hourInt := milliseconds // 3600000.
	hour := hourInt _digitsAsString.
	min := (milliseconds \\ 3600000 // 60000) _digitsAsString.
	sec := (milliseconds // 1000 \\ 60) _digitsAsString.
	aString := String new.
	(anArray at: 3)
		ifTrue: 
			["12-hour format"
			hourInt > 12
				ifTrue: 
					[aString := aString , (hourInt - 12) _digitsAsString , timeSeparator asString , min.
					(anArray at: 2) ifTrue: [aString := aString , timeSeparator asString , sec]]
				ifFalse: 
					[aString := aString , (hourInt == 0 ifTrue: ['12'] ifFalse: [hour]) , timeSeparator asString , min.
					(anArray at: 2) ifTrue: [aString := aString , timeSeparator asString , sec]].
			aString := aString , (hourInt >= 12 ifTrue: [' PM'] ifFalse: [' AM'])]
		ifFalse: 
			[aString := aString , hour , timeSeparator asString , min.
			(anArray at: 2) ifTrue: [aString := aString , timeSeparator asString , sec]].
	^aString!

stonContainSubObjects
	^false!

stonOn: stonWriter
	"Use an ISO style HH:MM:SS representation"

	stonWriter writeObject: self listSingleton: (self asStringUsingFormat: #($: true false))! !
!Time categoriesFor: #asStringUsingFormat:!must not strip!public!ston! !
!Time categoriesFor: #stonContainSubObjects!must not strip!public! !
!Time categoriesFor: #stonOn:!must not strip!public! !

!Time class methodsFor!

fromSton: stonReader
	^self fromString: stonReader parseListSingleton usingFormat: #($: true false)!

fromStream: aStream usingFormat: anArray
	"Creates and returns an instance of the receiver by reading a String from
 aStream.  The String expresses Greenwich Mean Time in the format specified by
 anArray.  The expression is terminated either by a space Character or by the
 end of the Stream.  Generates an error if the String does not conform to the
 format, or if anArray contains an incorrect formatting specification.

 See the class documentation of Time for a complete description of the
 String-formatting specification Array."

	| hourInt minInt secInt timeDelim ampm ampmPresent secondsPresent parseField totalSeconds |
	"This block returns a string up from the input stream up to the specified
 delimiter.  If also allows an end-of-file if that parameter is set true.
 It then skips over the delimiter if it is found.
"
	parseField := 
			[:delim :allowEof |
			| str |
			str := aStream contents class new.
			[(aStream peek = delim) not and: [aStream atEnd not]]
				whileTrue: [str := str , aStream next asString].
			aStream atEnd
				ifTrue: [allowEof ifFalse: [self error: 'Bad Time format']]
				ifFalse: [aStream next	"skip over delimiter"].
			str].
	timeDelim := anArray at: 1.
	secondsPresent := anArray at: 2.
	ampmPresent := anArray at: 3.
	hourInt := Integer fromString: (parseField value: timeDelim value: false).
	minInt := Integer
				fromString: (parseField value: (secondsPresent ifTrue: [timeDelim] ifFalse: [$\x20])
						value: (secondsPresent not and: [ampmPresent not])).
	secondsPresent
		ifTrue: [secInt := Integer fromString: (parseField value: $\x20 value: ampmPresent not)]
		ifFalse: [secInt := 0].
	ampmPresent
		ifTrue: 
			[hourInt < 0 ifTrue: [self error: 'Bad Time format'].
			hourInt > 12 ifTrue: [self error: 'Bad Time format'].
			ampm := String new.
			ampm := ampm
						, aStream next asString;
						add: aStream next.
			ampm = 'PM'
				ifTrue: 
					[hourInt := hourInt + 12.
					hourInt == 24 ifTrue: [hourInt := 12]]
				ifFalse: 
					[ampm = 'AM' ifFalse: [self error: 'Bad Time format'].
					hourInt == 12 ifTrue: [hourInt := 0]]].
	totalSeconds := hourInt * 3600 + (minInt * 60) + secInt.
	^self fromSeconds: totalSeconds!

fromString: aString usingFormat: anArray
	"Creates and returns an instance of the receiver from the String aString.
 The String expresses local time in the format specified by anArray.
 The expression is terminated either by a space Character or by the end of the
 String.  Generates an error if the String does not conform to the format,
 or if anArray contains an incorrect formatting specification.

 See the class documentation of Time for a complete description of the
 String-formatting specification Array."

	| s result |
	s := ReadStream on: aString.
	result := self fromStream: s usingFormat: anArray.
	[s atEnd] whileFalse: [s next = $\x20 ifFalse: [self error: 'Invalid Time format']].
	^result! !
!Time class categoriesFor: #fromSton:!must not strip!public! !
!Time class categoriesFor: #fromStream:usingFormat:!public!ston! !
!Time class categoriesFor: #fromString:usingFormat:!public!ston! !

!UndefinedObject methodsFor!

stonOn: stonWriter
	stonWriter writeNull! !
!UndefinedObject categoriesFor: #stonOn:!must not strip!public! !

"End of package definition"!

